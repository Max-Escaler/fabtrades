#!/usr/bin/env node

import { spawn } from 'child_process';
import path from 'path';
import fs from 'fs';

// Colors for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m'
};

// Helper function to print colored output
function printColor(color, text) {
  console.log(`${color}${text}${colors.reset}`);
}

// Helper function to print header
function printHeader() {
  console.log('\n' + '='.repeat(60));
  printColor(colors.bright + colors.blue, 'ðŸ§ª FAB Trades Test Suite');
  console.log('='.repeat(60));
}

// Helper function to run command with output capture
function runCommandWithCapture(command, args, options = {}) {
  return new Promise((resolve, reject) => {
    let output = '';
    let errorOutput = '';
    
    const child = spawn(command, args, {
      stdio: ['inherit', 'pipe', 'pipe'],
      shell: true,
      ...options
    });

    child.stdout.on('data', (data) => {
      const text = data.toString();
      output += text;
      process.stdout.write(text); // Still show output in real-time
    });

    child.stderr.on('data', (data) => {
      const text = data.toString();
      errorOutput += text;
      process.stderr.write(text); // Still show errors in real-time
    });

    child.on('close', (code) => {
      if (code === 0) {
        resolve({ success: true, output, errorOutput });
      } else {
        resolve({ success: false, output, errorOutput, exitCode: code });
      }
    });

    child.on('error', (error) => {
      reject(error);
    });
  });
}

// Helper function to run command (original version)
function runCommand(command, args, options = {}) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, {
      stdio: 'inherit',
      shell: true,
      ...options
    });

    child.on('close', (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`Command failed with exit code ${code}`));
      }
    });

    child.on('error', (error) => {
      reject(error);
    });
  });
}

// Function to save test results to log file
function saveTestResultsToLog(output, errorOutput, command) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const logDir = path.join(process.cwd(), 'test-logs');
  const logFile = path.join(logDir, `test-results-${timestamp}.log`);
  
  // Ensure log directory exists
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir, { recursive: true });
  }
  
  const logContent = [
    `# FAB Trades Test Results`,
    `Generated: ${new Date().toLocaleString()}`,
    `Command: ${command}`,
    `Timestamp: ${timestamp}`,
    '',
    '## Full Output',
    '```',
    output,
    '```',
    '',
    '## Error Output',
    '```',
    errorOutput,
    '```',
    '',
    '## Summary',
    `- Command: ${command}`,
    `- Exit Code: ${output.includes('Test Suites:') ? 'Tests ran' : 'Command failed'}`,
    `- Log File: ${logFile}`,
    ''
  ].join('\n');
  
  fs.writeFileSync(logFile, logContent);
  return logFile;
}

// Function to extract failed tests from output
function extractFailedTests(output) {
  const failedTests = [];
  const lines = output.split('\n');
  let currentTest = null;
  
  for (const line of lines) {
    // Look for test failure patterns
    if (line.includes('â—') && line.includes('failed')) {
      currentTest = line.trim();
    } else if (line.includes('âœ•') && currentTest) {
      failedTests.push({
        test: currentTest,
        error: line.trim()
      });
      currentTest = null;
    } else if (line.includes('TestingLibraryElementError') && currentTest) {
      failedTests.push({
        test: currentTest,
        error: line.trim()
      });
      currentTest = null;
    }
  }
  
  return failedTests;
}

// Function to save failed tests summary
function saveFailedTestsSummary(failedTests, command) {
  if (failedTests.length === 0) {
    return null;
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const logDir = path.join(process.cwd(), 'test-logs');
  const summaryFile = path.join(logDir, `failed-tests-${timestamp}.log`);
  
  // Ensure log directory exists
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir, { recursive: true });
  }
  
  const summaryContent = [
    `# Failed Tests Summary`,
    `Generated: ${new Date().toLocaleString()}`,
    `Command: ${command}`,
    `Total Failed Tests: ${failedTests.length}`,
    '',
    '## Failed Tests:',
    '',
    ...failedTests.map((test, index) => [
      `### ${index + 1}. ${test.test}`,
      `**Error:** ${test.error}`,
      ''
    ].join('\n')),
    '',
    `Generated by: node scripts/runTests.js ${command}`,
    `Log file: ${summaryFile}`
  ].join('\n');
  
  fs.writeFileSync(summaryFile, summaryContent);
  return summaryFile;
}

// Main test runner function
async function runTests() {
  const args = process.argv.slice(2);
  const command = args[0] || 'test';

  printHeader();

  try {
    switch (command) {
      case 'test':
        printColor(colors.cyan, 'Running all tests...');
        const testResult = await runCommandWithCapture('npm', ['run', 'test']);
        
        if (!testResult.success) {
          const logFile = saveTestResultsToLog(testResult.output, testResult.errorOutput, 'test');
          const failedTests = extractFailedTests(testResult.output);
          const summaryFile = saveFailedTestsSummary(failedTests, 'test');
          
          printColor(colors.red, `\nâŒ Tests failed!`);
          printColor(colors.yellow, `ðŸ“„ Full results saved to: ${logFile}`);
          if (summaryFile) {
            printColor(colors.yellow, `ðŸ“‹ Failed tests summary: ${summaryFile}`);
          }
        } else {
          printColor(colors.green, '\nâœ… All tests passed!');
        }
        break;

      case 'watch':
        printColor(colors.cyan, 'Running tests in watch mode...');
        printColor(colors.yellow, 'Press Ctrl+C to stop watching');
        await runCommand('npm', ['run', 'test:watch']);
        break;

      case 'coverage':
        printColor(colors.cyan, 'Running tests with coverage report...');
        const coverageResult = await runCommandWithCapture('npm', ['run', 'test:coverage']);
        
        if (!coverageResult.success) {
          const logFile = saveTestResultsToLog(coverageResult.output, coverageResult.errorOutput, 'coverage');
          const failedTests = extractFailedTests(coverageResult.output);
          const summaryFile = saveFailedTestsSummary(failedTests, 'coverage');
          
          printColor(colors.red, `\nâŒ Coverage tests failed!`);
          printColor(colors.yellow, `ðŸ“„ Full results saved to: ${logFile}`);
          if (summaryFile) {
            printColor(colors.yellow, `ðŸ“‹ Failed tests summary: ${summaryFile}`);
          }
        } else {
          printColor(colors.green, '\nâœ… Coverage report generated!');
          printColor(colors.blue, 'ðŸ“Š View detailed coverage at: coverage/lcov-report/index.html');
        }
        break;

      case 'ci':
        printColor(colors.cyan, 'Running tests for CI/CD pipeline...');
        const ciResult = await runCommandWithCapture('npm', ['run', 'test:ci']);
        
        if (!ciResult.success) {
          const logFile = saveTestResultsToLog(ciResult.output, ciResult.errorOutput, 'ci');
          const failedTests = extractFailedTests(ciResult.output);
          const summaryFile = saveFailedTestsSummary(failedTests, 'ci');
          
          printColor(colors.red, `\nâŒ CI tests failed!`);
          printColor(colors.yellow, `ðŸ“„ Full results saved to: ${logFile}`);
          if (summaryFile) {
            printColor(colors.yellow, `ðŸ“‹ Failed tests summary: ${summaryFile}`);
          }
        } else {
          printColor(colors.green, '\nâœ… CI tests completed successfully!');
        }
        break;

      case 'debug':
        printColor(colors.cyan, 'Running tests in debug mode...');
        printColor(colors.yellow, 'Debugger will pause on first test failure');
        await runCommand('npm', ['run', 'test:debug']);
        break;

      case 'lint':
        printColor(colors.cyan, 'Running ESLint...');
        await runCommand('npm', ['run', 'lint']);
        printColor(colors.green, '\nâœ… Linting passed!');
        break;

      case 'build':
        printColor(colors.cyan, 'Building project...');
        await runCommand('npm', ['run', 'build']);
        printColor(colors.green, '\nâœ… Build completed successfully!');
        break;

      case 'full':
        printColor(colors.cyan, 'Running full test suite...');
        
        // Run linting first
        printColor(colors.blue, '\nðŸ” Step 1: Linting...');
        await runCommand('npm', ['run', 'lint']);
        
        // Run tests with coverage
        printColor(colors.blue, '\nðŸ§ª Step 2: Running tests with coverage...');
        const fullTestResult = await runCommandWithCapture('npm', ['run', 'test:coverage']);
        
        if (!fullTestResult.success) {
          const logFile = saveTestResultsToLog(fullTestResult.output, fullTestResult.errorOutput, 'full');
          const failedTests = extractFailedTests(fullTestResult.output);
          const summaryFile = saveFailedTestsSummary(failedTests, 'full');
          
          printColor(colors.red, `\nâŒ Tests failed in full suite!`);
          printColor(colors.yellow, `ðŸ“„ Full results saved to: ${logFile}`);
          if (summaryFile) {
            printColor(colors.yellow, `ðŸ“‹ Failed tests summary: ${summaryFile}`);
          }
        }
        
        // Build project
        printColor(colors.blue, '\nðŸ—ï¸  Step 3: Building project...');
        await runCommand('npm', ['run', 'build']);
        
        printColor(colors.green, '\nðŸŽ‰ Full test suite completed!');
        break;

      case 'help':
      case '--help':
      case '-h':
        printHelp();
        break;

      default:
        printColor(colors.red, `âŒ Unknown command: ${command}`);
        printHelp();
        process.exit(1);
    }
  } catch (error) {
    printColor(colors.red, `\nâŒ Error: ${error.message}`);
    process.exit(1);
  }
}

// Help function
function printHelp() {
  console.log('\nðŸ“š Available Commands:');
  console.log('  test          Run all tests once');
  console.log('  watch         Run tests in watch mode');
  console.log('  coverage      Run tests with coverage report');
  console.log('  ci            Run tests for CI/CD pipeline');
  console.log('  debug         Run tests in debug mode');
  console.log('  lint          Run ESLint only');
  console.log('  build         Build project only');
  console.log('  full          Run complete test suite (lint + test + build)');
  console.log('  help          Show this help message');
  
  console.log('\nðŸ“– Usage Examples:');
  console.log('  node scripts/runTests.js test');
  console.log('  node scripts/runTests.js coverage');
  console.log('  node scripts/runTests.js full');
  
  console.log('\nðŸ“„ Log Files:');
  console.log('  - Failed tests are automatically saved to test-logs/');
  console.log('  - Full test results: test-results-{timestamp}.log');
  console.log('  - Failed tests summary: failed-tests-{timestamp}.log');
  
  console.log('\nðŸ”§ Test Configuration:');
  console.log('  - Jest config: jest.config.js');
  console.log('  - Test setup: src/setupTests.js');
  console.log('  - Coverage threshold: 80%');
  console.log('  - Test timeout: 10 seconds');
}

// Run the test runner
runTests().catch((error) => {
  printColor(colors.red, `\nðŸ’¥ Fatal error: ${error.message}`);
  process.exit(1);
});

export { runTests, runCommand };
